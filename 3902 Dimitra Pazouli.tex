\documentclass{article}
\usepackage{graphicx} 
\usepackage{ucs}
\usepackage[utf8x]{inputenc}
\usepackage{amsfonts} 
\usepackage[greek,english]{babel}
\usepackage{tcolorbox}
\newcommand{\en}{\selectlanguage{english}}
\newcommand{\gr}{\selectlanguage{greek}}
\usepackage{mathtools}          
\DeclarePairedDelimiter\Floor\lfloor\rfloor
\DeclarePairedDelimiter\Ceil\lceil\rceil
\usepackage{tcolorbox}
\tcbuselibrary{minted,breakable,xparse,skins}

\definecolor{bg}{gray}{0.95}
\DeclareTCBListing{mintedbox}{O{}m!O{}}{%
  breakable=true,
  listing engine=minted,
  listing only,
  minted language=#2,
  minted style=default,
  minted options={%
    linenos,
    gobble=0,
    breaklines=true,
    breakafter=,,
    fontsize=\small,
    numbersep=8pt,
    #1},
  boxsep=0pt,
  left skip=0pt,
  right skip=0pt,
  left=25pt,
  right=0pt,
  top=3pt,
  bottom=3pt,
  arc=5pt,
  leftrule=0pt,
  rightrule=0pt,
  bottomrule=2pt,
  toprule=2pt,
  colback=bg,
  colframe=orange!70,
  enhanced,
  overlay={%
    \begin{tcbclipinterior}
    \fill[orange!20!white] (frame.south west) rectangle ([xshift=20pt]frame.north west);
    \end{tcbclipinterior}},
  #3}




\title{\en 1o Project \grστο μάθημα της Κρυπτογραφίας}
\author{\gr Δήμητρα Παζούλη, 3902 }
\date{May 2023}

\begin{document}
\maketitle
\section*{\gr Άσκηση 1}
\begin{tcolorbox}
\grΤο επόμενο κρυπτόγραμμα έχει ληφθεί: \\
\centerline{\textbf{οκηθμφδζθγοθχυκχσφθμφμχγ}}\\
Ο αλγόριθμος κρυπτογράφησης είναι ο εξής: Κάθε γράμμα του αρχικού μας μηνύματος αντικαθίσταται από
την αριθμητική του τιμή (α → 1, ..., ω → 24). Ας είναι $x_0$ μία ρίζα του τριωνύμου $g(x) = x^2+ 3x + 1$. Σε κάθε αριθμό του μηνύματός μου προσθέτω την τιμή του πολυωνύμου $f(x) = x^5+3x^3+7x^2+3x^4+5x+4$,
στο $x_0$. Αντικαθιστώ κάθε αριθμό με το αντίστοιχο γράμμα. Βρείτε το αρχικό μήνυμα.
\end{tcolorbox}
\gr Ο συγκεκριμένος αλγόριθμος κρυπτογράφησης είναι ιδιαίτερα απλός στην κατανόηση, καθώς δεν χρειάστηκε πάνω από 10-15 γραμμές στην γλώσσα προγραμματισμού \en Python \gr για να υλοποιηθεί. \\
Οι συναρτήσεις \en \textbf{greek\_to\_num()} \gr και \en \textbf{num\_to\_greek()}\gr, που αντιστοιχίζουν τους χαρακτήρες του ελληνικού αλφαβήτου στις αριθμητικές τιμές τους και αντίστροφα, αξιοποιούν τις συναρτήσεις \en ord() \gr και \en char() \gr της \en Python. \gr Συγκεκριμένα, η θέση του χαρακτήρα άλφα (α) βρίσκεται στην θέση 945, άρα αρκεί να αφαιρέσουμε το 944 για να φέρουμε το τον χαρακτήρα άλφα στην επιθυμητή τιμή 1. Ομοίως πράττουμε και για τις υπόλοιπες τιμές. Βέβαια, επειδή στον πίνακα \en ASCII \gr υπάρχει και το τελικό σίγμα (ς) στην θέση 962 δημιουργείται μια μικρή επιπλοκή που πρέπει να προσέξουμε, αφού το αλφάβητο του δικού μας αλγόριθμου αποτελείται μόνο από 24 χαρακτήρες, χωρίς να συμπεριλαμβάνεται αυτός. \\
Ο αλγόριθμος λοιπόν επιλέγει κάθε χαρακτήρα του \en ciphertext \gr ξεχωριστά, τον μετατρέπει στην αριθμητική του τιμή μέσω την συνάρτησης που προαναφέραμε, \textbf{αφαιρεί} από τον αριθμό αυτό την τιμή του πολυωνύμου της εκφώνησης και ύστερα πραγματοποίεται η αντίστροφη μετατροπή από νούμερο σε αλφαβητικό χαρακτήρα. Στην 2η μετατροπή είναι σημαντικό να προσέξουμε ο αριθμός να μην βγει έξω από τα όρια 1 έως 24. Επομένως, εκτελούμε πρώτα την πράξη \en( $x$ mod 24 \gr) + 1. \\
Εισάγοντας στο πρόγραμμα μας το κρυπτόγραμμα που δόθηκε στην εκφώνηση, λαμβάνουμε την φράση \textbf{'μηδεισαγεωμετρητοσεισιτω'}. Προσθέτοντας τα απαραίτητα κενά παρατηρούμε πως πρόκειται για την επιγραφή στην είσοδο της Ακαδημίας του Πλάτωνα.


\section*{\gr Άσκηση 2}
\begin{tcolorbox}
\gr Αποκρυπτογραφήστε το κείμενο που σας δόθηκε, το οποίο κρυπτογραφήθηκε με τον αλγόριθμο του \en Vigenère. \gr Συστήνουμε να χρησιμοποιήσετε \en python. \gr Για το μήκος του κλειδιού μπορείτε να χρησιμοποιήσετε είτε \en  test Kasiski \gr  ή τη μέθοδο του \en Friedman.
\end{tcolorbox}
\gr Για την αποκρυπτογράφηση εκτελούμε τα παρακάτω βήματα:
\begin{enumerate}
\item Με την μέθοδο \en Kasiski \gr βρίσκουμε το μήκος και ύστερα το περιεχόμενο του κλειδιού το οποίο χρησιμοποιήθηκε για την κρυπτογράφηση του αρχικού μηνύματος.
\item Χρησιμοποιόντας την συνάρτηση \en \textbf{longKey(key, length))}, \gr επαναλαμβάνουμε το κλειδί στον εαυτό του μέχρι να φτάσει στο επιθυμητό μήκος, δηλαδή να έχει ίσο μήκος με το κρυπτόγραμμα. Παραδείγματος χάριν, για \en length = 10 \gr έχουμε \en DOG → DOGDOGDOGD. \gr
\item Αντιστιχίζουμε κάθε γράμμα του \en key \gr και \en ciphertext \gr στις αριθμητικές του τιμές (A → 0, ..., Z → 25). Αφαιρούμε τις τιμές του κλειδιού από τις τιμές του \en ciphertext \gr, ώστε να λάβουμε τα \en plaintext numbers. \grΠροσέχουμε ο αριθμός να μην βγει έξω από τα όρια 0 έως 25, άρα εκτελούμε  την πράξη \en( $x$ mod 26 \gr) Το βήμα (3) που μόλις περιγράψαμε αναλαμβάνει η \en \textbf{decipher\_vigenere(c, key)}. \gr
\item Μετατρέπουμε τα \en plaintext numbers \gr πίσω σε χαρακτήρες του αλφάβητου χρησιμοποιώντας την συνάρτηση της \en Python chr(x + 65). \gr Ο λόγος που προσθέτουμε την τιμή 65 είναι επειδή στο \en Unicode ASCII table \gr to κεφαλαίο λατινικό A βρισκεται στην θεση 65. Το αρχικό μήνυμα είναι πλέον έτοιμο προς εκτύπωση στον χρήστη.
\end{enumerate}
Εφαρμόζουμε τα παραπάνω για τα παραδείγματα που δόθηκαν στην εκφώνηση και βρίσκουμε πως τα κλειδιά των κειμένων είναι \en 'EMPEROR' \gr και \en 'SHANNON' \gr αντίστοιχα. Εκτελώντας τον κώδικα λαμβάνουμε την περίφημη ομιλία από την ταινία \en {\textbf{The Great Dictator (1940)} \gr και το επιδραστικό άρθρο του \en Claude Shannon \gr με τίτλο \en {\textbf{'Creative Thinking'(1952)}. \gr

\section*{\gr Άσκηση 3}
\begin{tcolorbox}
\gr΄Εστω ένα μήνυμα  $m$,  \en 16-bits. \gr  Θεωρούμε την κυκλική κύλιση προς τα αριστερά $<<$ \en a \gr κατά
\en a  bits. \gr΄Εστω ότι το $m$ κωδικοποιείται στο $c$ σύμφωνα με τον τύπο,\\
\centerline{$c = m ⊕ (m << 6) ⊕ (m << 10)$} \\
Βρείτε τον τύπο αποκωδικοποίησης. Δηλαδή, γράψτε το $m$ ως συνάρτηση του $c$. Υλοποιήστε κατάλληλο
κώδικα, για να δείξετε ότι ο τύπος που φτιάξατε είναι σωστός.
\end{tcolorbox}
Έστω $c =  c_0 c_1 c_2 c_3 ... c_{15} $ και $m = m_0 m_1 m_2 m_3 ... m_{15}$\\
Απο τον τύπο κωδικοποίησης προκύπτει ότι:\\
$c_k = m_k ⊕ m_{k+6} ⊕ m_{k+10} ∀ k = 0,1,2..15$ Παρατηρουμε ότι \\
\begin{equation}
c_{k+6} ⊕ c_{k+12} = m_{k+6} ⊕ m_{k+12} ⊕ m_{k+16} ⊕ m_{k+12} ⊕ m_{k+18} ⊕ m_{k+22} = m_k ⊕ m_{k+2}
\end{equation}
επειδή $c$, $m$ 16 \en bits \gr ισχύει ότι $c_j = c_{j+16x} ∀j=0,1,2,3..15$ και $∀x∈ \mathbb{Z}$\\
Επειδή η επιλογή του $k$ είναι τυχαία, ισχύει επίσης ότι:\\
\begin{equation}
c_{k+8} ⊕ c_{k+14} = m_{k+2} ⊕ m_{k+4} 
\end{equation}
\begin{equation}
c_{k+10} ⊕ c_k = m_{k+4} ⊕ m_{k+6}
\end{equation}
\begin{equation}
c_k ⊕ c_{k+6} = m_{k+10} ⊕ m_{k+12}
\end{equation}
Παρατηρούμε ότι:\\
$(1) ⊕ (2) ⊕ (3) ⊕ (4) = m_k ⊕ m_{k+2} ⊕ m_{k+2} ⊕ m_{k+4} ⊕ m_{k+4} ⊕ m_{k+6} ⊕ m_{k+10} ⊕ m_{k+12} = m_k ⊕ m_{k+6} ⊕ m_{k+10} ⊕ m_{k+12} = c_k ⊕ m_{k+12} =>$\\
$ m_{k+12} = (1) ⊕ (2) ⊕ (3) ⊕ (4) ⊕ c_k = c_{k+6} ⊕ c_{k+12} ⊕ c_{k+8} ⊕ c_{k+14} ⊕ c_{k+10} ⊕ c_k ⊕ c_k ⊕ c_{k+6} ⊕ c_k =>$\\
$m_{k+12} = c ⊕ c_{k+8} ⊕ c_{k+10} ⊕ c_{k+12} ⊕ c_{k+14}$\\
Συνεπώς $m_k = c_{k-12} ⊕ c_{k-4} ⊕ c_{k-2} ⊕ c_k ⊕ c_{k+2}$\\
Επομένως, ο τύπος αποκωδικοποίησης είναι ο εξής:\\
\centerline{$m = c ⊕ (c << 2) ⊕ (c >> 2 ⊕ (c << 4) ⊕ (c << 12))$} \\
Για να επαληθεύσουμε την ορθότητα του αλγορίθμου αποκωδικοποίησης, αρκεί να πάρουμε όλα τα δυνατά μηνύματα $m$ μήκους \en 16-bits \gr και να εφαρμόσουμε στο καθένα. Πράγματι, αν τρέξετε τον επισυναπτόμενο κώδικα \en Python \gr παρατηρούμε πως $m = decipher(encode(m))$ ∀ δυαδικό αριθμό $m$, όπου $len(m) = 16$.
\\[0.5cm]
\section*{\gr Άσκηση 4}
\begin{tcolorbox}
Να αποδείξετε ότι, αν στο σύστημα μετατόπισης διαλέγουμε τυχαία
τα κλειδιά από το σύνολο {0, 1, ..., 23}, τότε το σύστημα έχει τέλεια ασφάλεια.
\end{tcolorbox}
Σύμφωνα με τον \en {\textbf{Shannon}, \gr τέλεια ασφάλεια σημαίνει ότι αν κάποιος έχει το 
κρυπτομήνυμα $c$, αυτό δεν του παρέχει καμιά πληροφορία για το αρχικό μήνυμα $m$, και 
αυτό συμβαίνει για κάθε $m, c$. Ικανή και αναγκαία συνθήκη για να έχει ένα 
κρυπτοσύστημα τέλεια ασφάλεια είναι : \\
\centerline{$Pr = ( C=c | P=m ) = Pr(C = c)$},\\
όπου $C$ το κρυπτογραφημένο μήνυμα, $P$ το αρχικό μήνυμα, $c$ ένα πιθανό κρυπτομήνυμα και $m$ ένα πιθανό αρχικό μήνυμα. Από την εκφώνηση ξέρουμε πως τα κλειδιά επιλέγονται εντελώς τυχαία, δηλαδή {\textbf{οι πιθανότητες να επιλεχθεί ένα απο τα 24 κλειδιά είναι ίσες$(=1/24)$}. Βάση των παραπάνω, μόνο με την απλή γνώση του $c$ η \en EVE \gr δεν μπόρει να αποσπάσει περισσότερες πληροφορίες για το \en plaintext \gr $m$, οπότε καταλήγουμε στο συμπέρασμα ότι το σύστημα έχει τέλεια ασφάλεια.



\section*{\gr Άσκηση 5}
\begin{tcolorbox}
Υλοποιήστε τον \en OTP\gr, αφού αρχικά μετατρέψετε το μήνυμά σας σε \en bits \gr με χρήση του πίνακα. Θα πρέπει να δουλεύουν η κρυπτογράφηση και η αποκρυπτογράφηση. Το μήνυμα δίνεται
κανονικά και εσωτερικά μετατρέπεται σε \en bits\gr. Το κλειδί είναι διαλεγμένο τυχαία και έχει μήκος όσο το μήκος του μηνύματός σας. Το αποτέλεσμα δίνεται όχι σε \en bits, \grαλλά με λατινικούς χαρακτήρες.
\end{tcolorbox}
\gr Για την κρυπτογράφηση ενός μηνύματος με την χρήση \en One Time Pad \gr εκτελούμε τα παρακάτω βήματα:
\begin{enumerate}
\item Δημιουργούμε ένα κλειδί το οποίο είναι (μεγαλύτερο ή) ίσο με το αρχικό μήνυμα. Το κλειδί αποτελείται από μια σειρά τυχαίων αριθμών ή γραμμάτων. Επομένως κατασκευάζουμε την συνάρτηση \en \textbf{random\_binary(length)} \gr, η οποία χρησιμοποιεί μια γεννήτρια ψευδοτυχαίων δυαδικών αριθμών \en random. randint(0, 1). \gr Να σημειωθεί πως εδώ πρέπει να γίνει \en import \gr η βιβλιοθήκη \en random \gr της \en Python\gr.
\item Ορίζουμε την λίστα \en \textbf{symbols = ['A', 'B', ..., 'Z', '.', '!', '?', ...]}\gr, βάση του πίνακα που μας δόθηκε στο \en textbook\gr, ο οποίος θα αποτελεί το αλφάβητο του συστήματός μας. Θα φανεί χρήσιμο αργότερα στην μετατροπή ενός αριθμού στο αντίστιχο λατινικό χαρακτήρα/σύμβολό του και αντίστροφα.
\item Μετατρέπουμε το μήνυμα σε δεκαδική μορφή και ύστερα σε δυαδική μορφή μέσω της συνάρτησης \en \textbf{text\_to\_binary(a)} \gr. Αυτό μπορεί να γίνει χρησιμοποιώντας το σχήμα κωδικοποίησης \en ASCII. \gr Κάθε χαρακτήρας/σύμβολο αντιστοιχίζεται σε ένα μοναδικό \en 5-bit \gr δυαδικό αριθμό.
\item Προσθέτουμε κάθε ψηφίο του μηνύματος στο αντίστοιχο ψηφίο του κλειδιού μαζί \en (mod 2), \gr χρησιμοποιώντας την συνάρτηση \en \textbf{XOR(a, b)}. \gr Το αποτέλεσμα θα είναι ένα κρυπτογραφημένο μήνυμα ως σειρά από 0 και 1.
\item  Μετατρέπουμε τους δυαδικούς αριθμούς πίσω σε γράμματα/σύμβολα. Η συνάρτηση \en \textbf{binary\_to\_text(a)} \gr επιλέγει ανά 5αδα τα ψηφία του δυαδικού αριθμού \en (str) \gr και τα μετατρεπει σε δεκαδικους αριθμους και υστερα σε γραμματα μέσω του \en index \gr από την λίστα \en symbols. \gr
\item Στέλνουμε το κρυπτογραφημένο μήνυμα και το κλειδί στον αποδέκτη.
\end{enumerate}
Για την αποκρυπτογράφηση ακολουθούμε την ακριβώς αντίστροφη διαδικασία, η οποία θα είναι πλέον πολύ ευκολότερη στην υλοποίηση αφού έχουμε όλες τις συναρτήσεις διαθέσιμες. Μόλις τελειώσουμε την αποκρυπτογράφηση \textbf{καταστρέφουμε το κλειδί}, καθώς η επαναχρησιμοποίηση του κλειδιού μπορεί να θέσει σε κίνδυνο την ασφάλεια του συστήματος.

\section*{\gr Άσκηση 6}
\begin{tcolorbox}
Αποδεικνύεται ότι το πλήθος των ανάγωγων πολυωνύμων βαθμού $n$ στο σώμα  $\mathbb{F}_2$ είναι \\
\[
N_2(n) = \frac{1}{n} \sum_{d|n} µ(d) 2^{\frac{n}{d}}
\]
όπου 
\[
  μ(d) = \en
  \begin{cases}
  1 & \text{$d=1$} \\
  (-1)^{k} & \text{\en $d = p_1 p_2$ · · · $p_k (p_i:$ \gr πρώτοι)} \\
  0 & \text{\grαλλού}
  \end{cases}
\]
Με το σύμβολο $d|n$ εννοούμε όλους τους θετικούς διαιρέτες του n. Π.χ. αν $n$ = 30, τότε \\
\centerline{$\{d|n : 1 ≤ d ≤ n\} = \{1, 2, 3, 5, 6, 10, 15, 30\}$.}\\
Με χρήση του συστήματος \en sagemath \gr υπολογίστε το $N_2(10)$.
\end{tcolorbox}
Παρακάτω βλέπουμε μία απλή υλοποίηση των δύο συναρτήσεων \en \textbf{m(d)} \gr και \en \textbf{N(n)}\gr. \\
Η συνάρτηση \en \textbf{contains\_square(num)} \gr επίσης παίζει βασικό ρόλο στην δομή του προγράμματός μας. Συγκεκριμένα, εξετάζει εάν ένας αριθμός ανήκει στην 2η ή στην 3η κατηγορία της συνάρτησης $µ(d)$. Aν το γινόμενο της παραγοντοποίησης του αριθμού είναι γινόμενων γνήσιων πρώτων αριθμών. Π.χ. το 20 ανήκει στην 3η κατηγορία, αφού ισχύει $2*2*5 = 20$. Αυτό είναι εφικτό μέσω της συνάρτησης του \en sagemath factor().\gr \\ 
Τέλος, υπολογίζουμε το πλήθος των ανάγωγων πολυωνύμων βαθμού $n$ στο σώμα  $\mathbb{F}_2$ $N_2(n)$ της εκφώνησης, δηλαδή αντικαθιστούμε όλους τους διαιρέτες του $n$ στον τύπο, τα προσθέτουμε και πολλαπλασιάζουμε το άθροισμα με $\frac{1}{n}$.
Για τιμή $n = 10$, παίρνουμε αποτέλεσμα $N_2(10) = 99$.
\en
\begin{mintedbox}{python}
def contains_square(n):
    factors = list(factor(n))
    for i in range(len(factors)):
        if factors[i][1] > 1:
            return True
    return False
def m(d):
    if d==1:
        return 1
    if not contains_square(d):
        k = len(prime_divisors(d))
        return (-1)**k
    return 0
def N(n):
    N = 0
    for d in divisors(n):
        N += m(d) * (2**(n/d))
    return (1/n)*N
N(10)
\end{mintedbox}
\gr

\section*{\gr Άσκηση 7}
\begin{tcolorbox}
Υλοποιήστε τον \en RC4. \grΧρησιμοποιώντας το κλειδί \en HOUSE \grκρυπτογραφήστε το μήνυμα
(ξαναγράψτε το κείμενο χωρίς κενά): \en \\
MISTAKES ARE AS SERIOUS AS THE RESULTS THEY CAUSE \\ \gr
Η υλοποίησή σας πρέπει και να αποκρυπτογραφεί σωστά.
\end{tcolorbox}
Ο αλγόριθμος \en RC4 \gr που υλοποίησα λειτουργεί ως εξής:
\begin{enumerate}
\item Το κλειδί \en RC4 \gr παράγεται με μια διαδικασία που ονομάζεται \en Key Scheduling Algorithm. \gr  Δημιουργούμε έναν πίνακα $S$ 256 \en byte \gr που αρχικοποιείται με τις τιμές 0 έως 255 με τη σειρά.
Το κλειδί χρησιμοποιείται για τη δημιουργία μεταθέσεων των τιμών στον πίνακα καταστάσεων με βάση το κλειδί.
\item  Μετά τη δημιουργία του κλειδιού \en RC4, \gr χρησιμοποιείται το \en stream generation \gr για τη δημιουργία μιας ροής ψευδοτυχαίων \en byte.\gr Το \en stream generation \gr χρησιμοποιεί τον πίνακα καταστάσεων $S$, ο οποίος αρχικοποιήθηκε στο βήμα 1. Πρόκειτα για έναν βρόγχο που επαναλαμβάνεται σε κάθε \en byte \gr στο απλό κείμενο. Για κάθε \en byte \gr στο απλό κείμενο, δημιουργείται ένα νέο \en byte \gr της ροής κλειδιών. Ο πίνακας $S$ ενημερώνεται με εναλλαγή τιμών με βάση τον τρέχοντα δείκτη και την τιμή του τρέχοντος \en byte \gr της ροής κλειδιών.
\item Εφαρμόζω την πράξη \en XOR \gr στην ροή κλειδιών που δημιουργείται και στο αρχικό κείμενο για την παραγωγή του κρυπτογραφημένου κειμένου.
\item Όσο αφορά την αποκρυπτογράφηση του κειμένου, χρησιμοποιώ το ίδιο κλειδί για να αρχικοποιήσω τον πίνακα $S$ και να δημιουργήσω την ίδια ροή κλειδιών που χρησιμοποιήθηκε για την κρυπτογράφηση του απλού κειμένου. Ύστερα εφαρμόζω πάλι την πράξη \en XOR \gr.
\end{enumerate}
Παραδείγματος χάριν, αν τρέξω τον αλγόριθμο παίρνω τα εξής αποτελέσματα:\\ \en
c =  0X150XDD0XA60X670XFE0X6A0XDD0X1A0X280X50X6D0...\\
m =  MISTAKESAREASSERIOUSASTHERESULTSTHEYCAUSE\\
PRESS ENTER TO EXIT\\
\gr
Eίναι σημαντικό να σημειωθεί ότι το \en RC4 \gr δεν θεωρείται πλέον ασφαλές και συνιστάται η χρήση άλλων αλγορίθμων κρυπτογράφησης όπως ο \en AES.\gr
\section*{\gr Άσκηση 8}
\begin{tcolorbox}
Αν Σ ένα σύνολο με $|$Σ$|$ συμβολίζουμε το πλήθος των στοιχείων του, υπολογίστε τη
διαφορική ομοιομορφία \en(diffential uniformity) \gr του \en S-box (4.2.3). \\
\centerline{Diff$(S) = max |\{z∈\{0,1\}^6\}: S(z ⊕ x) ⊕ S(z) = y|$} \\
\gr ΄Οσο μικρότερη είναι αυτή η ποσότητα, τόσο πιο ανθεκτικό είναι το \en S-Box \gr στη διαφορική κρυπτανάλυση.
\end{tcolorbox}
\textbf{\en S-Box= \gr}$\left[\begin{array}{cccccccccccccccc}
0 & 2 & 3 & 7 & 9 & 12 & 15 & 7 & 6 & 15 & 15 & 1 & 7 & 3 & 1 & 0   \\
1 & 5 & 6 & 13 & 4 & 1 & 5 & 11 & 7 & 8 & 7 & 1 & 1 & 3 & 2 & 13    \\
5 & 3 & 5 & 12 & 11 & 1 & 1 & 5 & 13 & 0 & 15 & 7 & 2 & 2 & 13 & 0  \\
3 & 12 & 3 & 11 & 2 & 2 & 2 & 4 & 6 & 5 & 5 & 0 & 4 & 3 & 1 & 0     \\
 \end{array}\right]$

Αρχικά μεταφέρουμε το \en S-box \gr από το \en textbook \gr σε ενα δισδιάστατο πίνακα \en 4x16 \gr με δυαδικούς αριθμούς αποθηκεύμενους ως \en string. \gr Τώρα με την συνάρτηση \en \textbf{S(num, sbox)} \gr μπορούμε να μετατρέπουμε ένα δυαδικό αριθμό \en 6-bit \gr σε \en 4-bit \gr σύμφωνα με τον πίνακα \en S-box. \gr Με δεδομένη μια είσοδο \en6 bit, \gr η έξοδος \en4 bit \gr βρίσκεται επιλέγοντας τη σειρά χρησιμοποιώντας τα εξωτερικά δύο \en bit \gr (το πρώτο και το τελευταίο \en bit)\gr και τη στήλη χρησιμοποιώντας τα εσωτερικά τέσσερα \en bit. \gr Για παράδειγμα, μια είσοδος '011011' έχει εξωτερικά bits '01' και εσωτερικά bits '1101', οπότε η αντίστοιχη έξοδος θα ήταν στην 2η σειρά και 14η στήλη. \\
Τώρα καλούμε την συνάρτηση \en \textbf{diff(sbox, n, max\_diff = 0)}. \gr Ως ορίσματα δίνουμε το \en S-box \gr της εκφώνησης και τον χώρο εισόδου μεγέθους, δηλαδή $16*4=64$. Υπολογίζει τη διαφορική ομοιομορφία βάση του τύπου που μας δόθηκε στην εκφώνηση. \\
Οι πράξεις \en XOR \gr ανάμεσα στους \en 6-bit \gr δυαδικούς αριθμούς εκτελούνται με την συνάρτηση \en\textbf{XOR(a, b)}, \grτις οποίας τα ορίσματα είναι \en string. \gr Ο λόγος που έκανα αυτήν την επιλογή είναι επειδή στην \en Python \gr δεν είναι δυνατό να ξεκινάει ένας ακέραιος με το 0, οπότε ορισμένοι δυαδικοί αριθμοί πχ $'011010'$ δεν θα ήτανε δυνατόν να αναπαρισταθούν με άλλο τρόπο πέρα της συμβολοσειράς.\\
\gr Η συνάρτηση \en \textbf{max\_count\_occurences(my\_list)}\gr χρησιμοποιεί την βιβλιοθήκη \en Collections \gr ώστε να υπολογίσει το πλήθος του πιο συχνού στοιχείου σε μία λίστα. Αν και θα ήτανε εφικτό να υλοποίηθει και με απλά \en for loops \gr κλπ., προτίμησα να χρησιμοποιήσω αυτή την βιβλιοθήκη ώστε να είναι ο κώδικας πιο αποδοτικός και εύκολα συντηρίσιμος.\\
Εκτελώντας τον κώδικα που μόλις περιγράψαμε, η διαφορική ομοιομορφία υπολογίζεται ίση με 14. 



\section*{\gr Άσκηση 9}
\begin{tcolorbox}
Εξετάστε αν ισχύει το \en avalanche effect \gr στον \en AES-128\gr. Αναλυτικότερα, φτιάξτε αρκετά
ζευγάρια $(> 30)$ μηνυμάτων $(m1, m2)$ που να διαφέρουν σε ένα \en bit. \gr Εξετάστε σε πόσα \en bits \gr διαφέρουν τα αντίστοιχα κρυπτομηνύματα. Δοκιμάστε με δύο καταστάσεις λειτουργίας : \en ECB \gr και  \en CBC \gr (η δεύτερη θέλει και \en IV block \gr). Τα μήκη των μηνυμάτων που θα χρησιμοποιήσετε να έχουν μήκος διπλάσιο του μήκους ενός
\en block. \gr Δηλαδή για τον \en AES-128, \gr να είναι μήκους \en 256 bits. \gr 
\end{tcolorbox}


\section*{\gr Άσκηση 10}
\begin{tcolorbox}
 \en (CTF-like) \gr Μπορείτε να ανοίξετε το \en secure.zip?
Hint. \gr ΄Οτι χρειάζεστε είναι στην διαφάνεια \en course-1-Introduction.pdf \gr
στο \en elearning \gr.
\end{tcolorbox}Με \en third-party programs \gr όπως \en John The Ripper \gr προσπάθησα να εφαρμόσω \en brute force\gr. Δυστυχώς λόγω περιορισμένου χρόνου (3 μέρες) δεν κατάφερα να καταλήξω σε κάποιο στοιχείο για τον κωδικό του αρχείου που μας δόθηκε.
\end{document}
